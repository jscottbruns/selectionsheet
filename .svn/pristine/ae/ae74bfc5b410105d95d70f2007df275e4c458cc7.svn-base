This is an example of the current state of the packer engine.
First, a page is created with default 1" margins.  Then, rectangular blocks are allocate()d to fragment the free space.  (Rectangles are drawn to show where the space was allocated, although there's no requirement that anything actually be painted in the allocated space)  Finally, this text is automatically filled onto the page using ->fill_text().
Once this is done, the script examines the internals of the packer class and draws a rectangle-with-slash where each remaining free space fragment exists.  A new page is then created, and a serialized version of the free space map is dumped.
You can see that the small fields (which did not meet the minwidth requirements) are not filled with text. You can also get a feel for the way the fragmentation policy works.
This test/example is where I first realized that fragmentation would occasionally result in fields that should obviously be joined.  The large field above the blue rectangle was originally 2 fragments, but was combined into 1 by the ->merge() method (which is automatically called after altering of the free space map to clean things up). I believe this is A Good Thing.
In this example, the policy of choosing the next field to fill by it's distance from the UL corner of the page works well, but I believe this will not always be the case.

I will now cut and paste some more text, just to fill up the remaining space.

The concept of the packer engine started with perl's Tk library, and the packer included. phppdflib's packer will run somewhat differently, since the main restraining factor is available page space and phppdflib can create new pages at will - two things the perl packer doesn't factor in to its reasoning.
The basic idea I have is that each page will store an array of rectangles that indicate the unused space on the page. Initially, a page will consist of a single rectangle (bounded by the page margins) All painting functions will remove the space they use from this pool, thus keeping track of how much space is still available to use on the page. Special functions will allow a client script to paint an object "in the next available space", and the packer should create new pages as needed to place objects.
The allotment of remaining space is not arbitrary, it attempts to keep the largest vertical area possible (b) since that's how text normally flows. A special function will exist to "fill in" text in the remaining space - the idea being that a user can place all her/his images in the document, and then automagically have the packer flow the text around the images.
Since this section was originally written, I believe I've solved some of the problems that orinally worried me. I feel that the code I currently have in place can handle any possible allocation of space from a collection of fields of arbitrary complexity. However, this has introduced new concerns: